# -*- coding: utf-8 -*-
"""CV_hw1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g3kQ2qzeXe7hNW2rVFQ3gLd8-5JmTk5Q
"""

# Commented out IPython magic to ensure Python compatibility.
import os
import cv2
import math
import random
import scipy.io
import numpy as np
import matplotlib.pyplot as plt
import zipfile
# %matplotlib inline

curve_path = './'

zip_name = os.path.join(curve_path, 'tone_curves.zip')
# 解壓縮文件
with zipfile.ZipFile(zip_name, 'r') as zip_ref:
    zip_ref.extractall(curve_path)

curve_name = os.path.join(curve_path, 'tone_curves.mat')
curve_inv_name = os.path.join(curve_path, 'tone_curves_inv.mat')
tone_curves = scipy.io.loadmat(curve_name)
tone_curves_inv = scipy.io.loadmat(curve_inv_name)

I = tone_curves['I'] # Irradiance 輻照度: 電磁輻射入射於曲面時每單位面積的功率。
B = tone_curves['B'] # Brightness 亮度
I_inv = tone_curves_inv['invI']
B_inv = tone_curves_inv['invB']

plt.figure(figsize=(18, 6))
plt.subplot(1, 2, 1)
plt.axis('off')
plt.imshow(I)
plt.title('Irradiance')
plt.subplot(1, 2, 2)
plt.axis('off')
plt.imshow(B)
plt.title('Brightness')

# Tone Curves Parameters
tone_index = 170
B[tone_index]

ccm = np.array([1.0234, -0.2969, -0.2266,
                -0.5625, 1.6328, -0.0469,
                -0.0703, 0.2188, 0.6406])
ccm = np.reshape(ccm, (3, 3))
ccm = (ccm / np.tile(np.sum(ccm, axis=1), [3, 1]).T).T
ccm_inv = np.linalg.inv(np.copy(ccm))

# White Balance Parameters
fr = 0.7715567349551743
fb = 0.9068480239589546

img = cv2.imread('/content/image.png')
plt.figure(figsize=(12, 6))
plt.axis('off')
plt.imshow(img)

img = cv2.imread('/content/image.png')
img_gt = img
np.array(img, dtype='uint8')

#### Remember that the image store in OpenCV is BGR instead of RGB
#### We should transfer to RGB first before ISP
plt.figure(figsize=(12, 6))
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
img = img.astype('double') / 255.0
plt.axis('off')
plt.imshow(img)

import numpy as np
import math

def tone_mapping(img, I, B, index=0, inv=False):
    '''
    Input:
        img: H*W*3 numpy array, input image.
        I: 201*1024 array, represents 201 tone curves for Irradiance.
        B: 201*1024 array, represents 201 tone curves for Brightness.
        index: int, choose which curve to use, default is 0
        inv: bool, judge whether tone mapping (False) or inverse tone mapping (True), default is False
    Output:
        output: H*W*3 numpy array, output image afte (inverse) tone mapping.
    '''
    ########################################################################
    # TODO:                                                                #
    #   Following above instruction to get tone mapping as output.         #
    #   and inverse tone mapping result as output                          #
    ########################################################################

    # 選擇特定索引的曲線
    selected_I_curve = I[index]
    selected_B_curve = B[index]

    # 根據選擇的曲線進行 tone mapping 或 inverse tone mapping
    if inv:
        # Inverse Tone Mapping
        # 使用逆曲線對輸入影像進行逆映射
        mapped_img = np.interp(img, selected_B_curve, selected_I_curve)
    else:
        # Tone Mapping
        # 使用曲線對輸入影像進行映射
        mapped_img = np.interp(img, selected_I_curve, selected_B_curve)

    # 限制映射後的像素值在 [0, 1] 範圍內
    mapped_img = np.clip(mapped_img, 0, 1)

    # 回傳映射後的影像
    return mapped_img

    ########################################################################
    #                                                                      #
    #                           End of your code                           #
    #                                                                      #
    ########################################################################

    # return output

img_inverse_tone = tone_mapping(img, I_inv, B_inv, index=tone_index, inv=True)

plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.axis('off')
plt.imshow(img)
plt.title('Oringal Image')
plt.subplot(1, 2, 2)
plt.axis('off')
plt.imshow(img_inverse_tone)
plt.title('Image after inverse tone')

# Example usage:
img_inverse_tone_XYZ = RGB2XYZ(img_inverse_tone)

plt.figure(figsize=(12, 6))
plt.subplot(1, 3, 1)
plt.axis('off')
plt.imshow(img)
plt.title('Oringal Image')
plt.subplot(1, 3, 2)
plt.axis('off')
plt.imshow(img_inverse_tone)
plt.title('Image after inverse tone')
plt.subplot(1, 3, 3)
plt.axis('off')
plt.imshow(img_inverse_tone_XYZ)
plt.title('Image after CIE')

def color_correction(img, ccm):
    '''
    Input:
        img: H*W*3 numpy array, input image
        ccm: 3*3 numpy array, color correction matrix
    Output:
        output: H*W*3 numpy array, output image after color correction
    '''
    ########################################################################
    # TODO:                                                                #
    #   Following above instruction to get color correction result         #
    #                                                                      #
    ########################################################################

    # 將輸入影像轉換為一維數組
    img_flat = img.reshape((-1, 3))

    # 使用 color correction matrix (ccm) 對每個像素進行矩陣運算
    corrected_img_flat = np.dot(img_flat, ccm)

    # 將一維數組轉換回原始影像形狀
    output = corrected_img_flat.reshape(img.shape)

    # 限制校正後的像素值在 [0, 1] 範圍內
    output = np.clip(output, 0, 1)

    ########################################################################
    #                                                                      #
    #                           End of your code                           #
    #                                                                      #
    ########################################################################

    #### Prevent the value larger than 1 or less than 0
    output = np.clip(output, 0, 1)
    return output

ccm

img_inverse_ccm = color_correction(img_inverse_tone_XYZ, ccm)

plt.figure(figsize=(14, 6))
plt.subplot(1, 4, 1)
plt.axis('off')
plt.imshow(img)
plt.title('Oringal Image')
plt.subplot(1, 4, 2)
plt.axis('off')
plt.imshow(img_inverse_tone)
plt.title('Image after inverse tone')
plt.subplot(1, 4, 3)
plt.axis('off')
plt.imshow(img_inverse_tone_XYZ)
plt.title('Image after CIE')
plt.subplot(1, 4, 4)
plt.axis('off')
plt.imshow(img_inverse_ccm)
plt.title('Image after CCM')

def mosaic(img, pattern):
    '''
    Input:
        img: H*W*3 numpy array, input image.
        pattern: string, 4 different Bayer patterns (GRBG, RGGB, GBRG, BGGR)
    Output:
        output: H*W numpy array, output image after mosaic.
    '''
    ########################################################################
    # TODO:                                                                #
    #   1. Create the H*W output numpy array.                              #
    #   2. Discard other two channels from input 3-channel image according #
    #      to given Bayer pattern.                                         #
    #                                                                      #
    #   e.g. If Bayer pattern now is BGGR, for the upper left pixel from   #
    #        each four-pixel square, we should discard R and G channel     #
    #        and keep B channel of input image.                            #
    #        (since upper left pixel is B in BGGR bayer pattern)           #
    ########################################################################

    # 創建 H*W 的輸出 numpy 陣列
    output = np.zeros_like(img[:,:,0])

    # 根據給定的 Bayer 模式，丟棄輸入 3 通道影像的其中兩個通道，僅保留特定通道
    if pattern == 'GRBG':
        output[::2, ::2] = img[::2, ::2, 1]  # Green at (0,0)
        output[1::2, ::2] = img[1::2, ::2, 0]  # Red at (1,0)
        output[::2, 1::2] = img[::2, 1::2, 2]  # Blue at (0,1)
        output[1::2, 1::2] = img[1::2, 1::2, 1]  # Green at (1,1)
    elif pattern == 'RGGB':
        output[::2, ::2] = img[::2, ::2, 0]  # Red at (0,0)
        output[1::2, ::2] = img[1::2, ::2, 1]  # Green at (1,0)
        output[::2, 1::2] = img[::2, 1::2, 1]  # Green at (0,1)
        output[1::2, 1::2] = img[1::2, 1::2, 2]  # Blue at (1,1)
    elif pattern == 'GBRG':
        output[::2, ::2] = img[::2, ::2, 2]  # Blue at (0,0)
        output[1::2, ::2] = img[1::2, ::2, 1]  # Green at (1,0)
        output[::2, 1::2] = img[::2, 1::2, 1]  # Green at (0,1)
        output[1::2, 1::2] = img[1::2, 1::2, 0]  # Red at (1,1)
    elif pattern == 'BGGR':
        output[::2, ::2] = img[::2, ::2, 1]  # Green at (0,0)
        output[1::2, ::2] = img[1::2, ::2, 2]  # Blue at (1,0)
        output[::2, 1::2] = img[::2, 1::2, 0]  # Red at (0,1)
        output[1::2, 1::2] = img[1::2, 1::2, 1]  # Green at (1,1)

    ########################################################################
    #                                                                      #
    #                           End of your code                           #
    #                                                                      #
    ########################################################################

    return output

def demosaic(img, pattern):
    '''
    Input:
        img: H*W numpy array, input RAW image.
        pattern: string, 4 different Bayer patterns (GRBG, RGGB, GBRG, BGGR)
    Output:
        output: H*W*3 numpy array, output de-mosaic image.
    '''
    # Create H*W*3 output array
    output = np.zeros((img.shape[0], img.shape[1], 3))

    if pattern == 'GRBG':
        output[::2, ::2, 1] = img[::2, ::2]  # Green at (0,0)
        output[1::2, ::2, 0] = img[1::2, ::2]  # Red at (1,0)
        output[::2, 1::2, 2] = img[::2, 1::2]  # Blue at (0,1)
        output[1::2, 1::2, 1] = img[1::2, 1::2]  # Green at (1,1)
    elif pattern == 'RGGB':
        output[::2, ::2, 0] = img[::2, ::2]  # Red at (0,0)
        output[1::2, ::2, 1] = img[1::2, ::2]  # Green at (1,0)
        output[::2, 1::2, 1] = img[::2, 1::2]  # Green at (0,1)
        output[1::2, 1::2, 2] = img[1::2, 1::2]  # Blue at (1,1)
    elif pattern == 'GBRG':
        output[::2, ::2, 2] = img[::2, ::2]  # Blue at (0,0)
        output[1::2, ::2, 1] = img[1::2, ::2]  # Green at (1,0)
        output[::2, 1::2, 1] = img[::2, 1::2]  # Green at (0,1)
        output[1::2, 1::2, 0] = img[1::2, 1::2]  # Red at (1,1)
    elif pattern == 'BGGR':
        output[::2, ::2, 1] = img[::2, ::2]  # Green at (0,0)
        output[1::2, ::2, 2] = img[1::2, ::2]  # Blue at (1,0)
        output[::2, 1::2, 0] = img[::2, 1::2]  # Red at (0,1)
        output[1::2, 1::2, 1] = img[1::2, 1::2]  # Green at (1,1)

    return output

pattern='RGGB'
img_mosaic = mosaic(img_inverse_ccm, pattern=pattern)

plt.figure(figsize=(18, 6))
plt.subplot(1, 5, 1)
plt.axis('off')
plt.imshow(img)
plt.title('Oringal Image')
plt.subplot(1, 5, 2)
plt.axis('off')
plt.imshow(img_inverse_tone)
plt.title('Image after inverse tone')
plt.subplot(1, 5, 3)
plt.axis('off')
plt.imshow(img_inverse_tone_XYZ)
plt.title('Image after CIE')
plt.subplot(1, 5, 4)
plt.axis('off')
plt.imshow(img_inverse_ccm)
plt.title('Image after CCM')
plt.subplot(1, 5, 5)
plt.axis('off')
plt.imshow(img_mosaic)
plt.title('Image after mosaic')

def generate_wb_mask(img, pattern, fr, fb):
    '''
    Input:
        img: H*W numpy array, RAW image
        pattern: string, 4 different Bayer patterns (GRBG, RGGB, GBRG, BGGR)
        fr: float, white balance factor of red channel
        fb: float, white balance factor of blue channel
    Output:
        mask: H*W numpy array, white balance mask
    '''
    ########################################################################
    # TODO:                                                                #
    #   1. Create a numpy array with shape of input RAW image.             #
    #   2. According to the given Bayer pattern, fill the fr into          #
    #      correspinding red channel position and fb into correspinding    #
    #      blue channel position. Fill 1 into green channel position       #
    #      otherwise.                                                      #
    ########################################################################

    # 創建一個與輸入 RAW 影像相同形狀的二維 numpy 陣列
    mask = np.ones((img.shape[0], img.shape[1]))

    # 根據給定的 Bayer 模式，填充白平衡因子到相應的通道位置
    if pattern == 'GRBG':
        mask[::2, ::2] = fr  # Red at (0,0)
        mask[1::2, 1::2] = fb  # Blue at (1,1)
    elif pattern == 'RGGB':
        mask[::2, ::2] = fr  # Red at (0,0)
        mask[::2, 1::2] = fb  # Blue at (0,1)
    elif pattern == 'GBRG':
        mask[1::2, ::2] = fr  # Red at (1,0)
        mask[1::2, 1::2] = fb  # Blue at (1,1)
    elif pattern == 'BGGR':
        mask[1::2, 1::2] = fr  # Red at (1,1)
        mask[::2, 1::2] = fb  # Blue at (0,1)

    ########################################################################
    #                                                                      #
    #                           End of your code                           #
    #                                                                      #
    ########################################################################

    return mask

fr = 0.7715567349551743
fb = 0.9068480239589546
wb_mask = generate_wb_mask(img_mosaic, pattern, fr, fb)
img_Inverse_WB = img_mosaic  * wb_mask

plt.figure(figsize=(18, 6))
plt.subplot(1, 6, 1)
plt.axis('off')
plt.imshow(img)
plt.title('Oringal Image')
plt.subplot(1, 6, 2)
plt.axis('off')
plt.imshow(img_inverse_tone)
plt.title('Image after inverse tone')
plt.subplot(1, 6, 3)
plt.axis('off')
plt.imshow(img_inverse_tone_XYZ)
plt.title('Image after CIE')
plt.subplot(1, 6, 4)
plt.axis('off')
plt.imshow(img_inverse_ccm)
plt.title('Image after CCM')
plt.subplot(1, 6, 5)
plt.axis('off')
plt.imshow(img_mosaic)
plt.title('Image after mosaic')
plt.subplot(1, 6, 6)
plt.axis('off')
plt.imshow(img_Inverse_WB)
plt.title('Image after Inverse WB')

wb_mask = generate_wb_mask(img_Inverse_WB, pattern, 1/fr, 1/fb)
img_WB = img_Inverse_WB * wb_mask
img_WB = np.clip(img_WB, 0, 1)

plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1);plt.axis('off')
plt.imshow(img_Inverse_WB)
plt.title('image Raw')
plt.subplot(1, 2, 2);plt.axis('off')
plt.imshow(img_WB)
plt.title('Image after WG')

img_demosaic = demosaic(img_WB, pattern=pattern) #pattern='RGGB'

plt.figure(figsize=(12, 6))
plt.subplot(1, 3, 1);plt.axis('off')
plt.imshow(img_Inverse_WB)
plt.title('image Raw')
plt.subplot(1, 3, 2);plt.axis('off')
plt.imshow(img_WB)
plt.title('Image after WG')
plt.subplot(1, 3, 3);plt.axis('off')
plt.imshow(img_demosaic)
plt.title('Image after demosaic')

img_color_correction = color_correction(img_demosaic, ccm_inv)

plt.figure(figsize=(14, 6))
plt.subplot(1, 4, 1);plt.axis('off')
plt.imshow(img_Inverse_WB)
plt.title('image Raw')
plt.subplot(1, 4, 2);plt.axis('off')
plt.imshow(img_WB)
plt.title('Image after WG')
plt.subplot(1, 4, 3);plt.axis('off')
plt.imshow(img_demosaic)
plt.title('Image after demosaic')
plt.subplot(1, 4, 4);plt.axis('off')
plt.imshow(img_color_correction)
plt.title('Image after Color Correction')

# 將64位元浮點數轉換為32位元浮點數
img_color_correction_32f = np.float32(img_color_correction)

# 將XYZ色彩空間轉換為BGR色彩空間
img_RGB = cv2.cvtColor(img_color_correction_32f, cv2.COLOR_XYZ2BGR)

plt.figure(figsize=(18, 6))
plt.subplot(1, 5, 1);plt.axis('off')
plt.imshow(img_Inverse_WB)
plt.title('image Raw')
plt.subplot(1, 5, 2);plt.axis('off')
plt.imshow(img_WB)
plt.title('Image after WG')
plt.subplot(1, 5, 3);plt.axis('off')
plt.imshow(img_demosaic)
plt.title('Image after demosaic')
plt.subplot(1, 5, 4);plt.axis('off')
plt.imshow(img_color_correction)
plt.title('Image after Color Correction')
plt.subplot(1, 5, 5);plt.axis('off')
plt.imshow(img_RGB)
plt.title('Image after XYZ2RGB')

img_tm = tone_mapping(img_RGB, I, B, index=tone_index, inv=False)

plt.figure(figsize=(18, 6))
plt.subplot(1, 6, 1);plt.axis('off')
plt.imshow(img_Inverse_WB)
plt.title('image Raw')
plt.subplot(1, 6, 2);plt.axis('off')
plt.imshow(img_WB)
plt.title('Image after WG')
plt.subplot(1, 6, 3);plt.axis('off')
plt.imshow(img_demosaic)
plt.title('Image after demosaic')
plt.subplot(1, 6, 4);plt.axis('off')
plt.imshow(img_color_correction)
plt.title('Image after Color Correction')
plt.subplot(1, 6, 5);plt.axis('off')
plt.imshow(img_RGB)
plt.title('Image after XYZ2RGB')
plt.subplot(1, 6, 6);plt.axis('off')
plt.imshow(img_tm)
plt.title('Image after tone mapping')

plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1);plt.axis('off')
plt.imshow(img)
plt.title('Oringal Image')
plt.subplot(1, 2, 2);plt.axis('off')
plt.imshow(img_tm)
plt.title('Image after inverse process')

def calculate_psnr(img1, img2):
    '''
    Input:
        img1, img2: H*W*3 numpy array
    Output:
        psnr: the peak signal-to-noise ratio value
    '''
    ########################################################################
    # TODO:                                                                #
    #   Following above instruction to get PSNR as output.                 #
    #                                                                      #
    ########################################################################

    # 將影像值轉換為浮點數
    img1 = img1.astype(np.float64)
    img2 = img2.astype(np.float64)

    # 計算差異影像
    mse = np.mean((img1 - img2) ** 2)

    # 如果 MSE 為零，表示兩張影像完全相同，PSNR 定義為無窮大
    if mse == 0:
        return float('inf')

    # 計算 PSNR
    max_pixel = 255.0
    psnr = 20 * np.log10(max_pixel / np.sqrt(mse))

    ########################################################################
    #                                                                      #
    #                           End of your code                           #
    #                                                                      #
    ########################################################################
    return psnr

calculate_psnr(img, img_tm)